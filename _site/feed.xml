<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kia Rahmani</title>
    <description>I am a first year PhD student of Computer Science @Purdue. I am mostly interested in Design, Anlysis and Verification of Programming Languages. I work with Proefssor Suresh Jagannathan. 
</description>
    <link>http://yourdomain.com/</link>
    <atom:link href="http://yourdomain.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 22 Apr 2016 18:49:24 -0400</pubDate>
    <lastBuildDate>Fri, 22 Apr 2016 18:49:24 -0400</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Verdi, A Framework for Impementing and Formally Verifying Distributed Systems</title>
        <description>&lt;p&gt;Assume you want to design a distributed system and you are told that you sould not be woried about the underlying network, since it is reliable. Every message is delivered exactly once and there is no site failure. You design and implement your system easily. You define nodes, states they preserve and also messages with appropriate handlers. Assume your system is a central counter that could be inceremented by clients. Obviously, possible messages from clients are &lt;code class=&quot;highlighter-rouge&quot;&gt;inc()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;query()&lt;/code&gt;. The server also can respond with &lt;code class=&quot;highlighter-rouge&quot;&gt;counter:n&lt;/code&gt; where n is a natural number. &lt;br /&gt;
Now you are asked for the specification of your system with a proof of correctness.
You define the following predicate for the traces of messages and prove that all possible traces in your system satisfy it:&lt;/p&gt;
&lt;p&gt; 
&amp;#934;(&amp;#964;) :=   &amp;#964; =  &amp;#964;&lt;sub&gt;1&lt;/sub&gt;  ++   &amp;lt;x,counter:n&amp;gt; ++ &amp;#964;&lt;sub&gt;2&lt;/sub&gt; ++ &amp;lt;y,counter:n+1&amp;gt; ++  &amp;#964;&lt;sub&gt;3&lt;/sub&gt;     &amp;#x2192; &amp;exist;z, &amp;lt;z,inc()&amp;gt; =  &amp;#964;&lt;sub&gt;2&lt;/sub&gt; 
&lt;/p&gt;
&lt;p&gt;So far everthing is working perfect, but after your system is actually implemented, they realize that the network has some bugs and drops messages, so the safety features of your system are violated. Now you are required to design another system and prove its correctness in this new environment. &lt;/p&gt;
&lt;p&gt;Well, this is not a major problem for you, since there are already solutions for this problem in the community: simply add a sequence number to each message, and make sure that consecutive messages from each sender have consecutive numbers, otherwise ask the sender to send you the lost message. This just requires a simple wraper around your code that examines each message and compares its sequence number with the last message received from that sender, and takes proper actions. &lt;/p&gt;
&lt;p&gt;However, you do not want to go over all steps again, specially proving the correctness of your system was by no mean trivial and it is now even harder.&lt;br /&gt;That is where &lt;a href=&quot;http://verdi.uwplse.org&quot;&gt;Verdi&lt;/a&gt; comes into play! If you had implemented and proved your system in Verdi, you could now simply pick another network semantics and rely on Verdi to generate a new code, new safety specifications and a new proof of correctness for the translated system. &lt;p&gt;  
&lt;p&gt; Verdi automatically, wraps your code with certain handlers to make it immune to different types of network faults and node crashes. It provides a spectrum of network semantics that you could chose from and returns translated system and proofs. you should only verify your application in an idealized fault model, and then apply a Verdi&#39;s Verified System Transformers to obtain an application that is &lt;b&gt;guaranteed&lt;/b&gt; to have analogous properties in a more realistic environment.
&lt;/p&gt;&lt;/p&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://yourdomain.com/2016/04/22/Verdi.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2016/04/22/Verdi.html</guid>
        
        
      </item>
    
      <item>
        <title>Definitions VS Implementation</title>
        <description>&lt;p&gt;Let’s dive into the problem. Consider the following code, which is a definition of a simple counter with two functions, query and incerement:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coq&quot;&gt;Definition GCounter_State : Set := nat.

Inductive GCounter : Type :=
|ConsGCounter : GCounter_State -&amp;gt; GCounter.

Definition GCounter_read (c: GCounter): GCounter_State:=
  match c with
    |ConsGCounter n =&amp;gt; n
  end.

Definition GCounter_inc (c: GCounter): GCounter :=
  match c with
    |ConsGCounter n =&amp;gt; ConsGCounter (n+1)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could make it even simpler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coq&quot;&gt;Definition GCounter&#39; := nat.
Definition GCounter&#39;_read (c:GCounter&#39;): nat := c.  
Definition GCounter&#39;_inc (c:GCounter&#39;): GCounter&#39; := c+1.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Consider either of the definitions above. They both specify what you (as a programmer) expect from a counter datatype; it preserves a natural number for you, and lets you to increment it.
&lt;br /&gt;
Now imagine you (as a language designer) are given one the above definitions and asked to equip your language with such a datatype. In an isolated system with no failure, this would be a piece of cake. 
But what if you are asked to implement it as a replicated data object?&lt;br /&gt; 
Considering the amzing capabalities of CRDTs (Which in my opinion, are the best things you can get, within limitation of CAP theorem, &lt;a href=&quot;https://vaughnvernon.co/?p=1012&quot;&gt;read more&lt;/a&gt;)
you decide to implement the counter as a CRDT as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coq&quot;&gt;Inductive GCtr_Eff: Type := |inc.

Definition GCtr:Type := list GCtr_Eff.

Definition GCtr_read (c:GCtr) : nat := length c.

Definition GCtr_inc (c:GCtr) : GCtr := (cons inc c).

Definition Gctr_resolve  (c1 : GCtr_Eff) (c2 : GCtr_Eff) :list GCtr_Eff :=
  match (c1,c2) with
    | (inc,inc) =&amp;gt; cons inc (cons inc nil)
  end.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You are done, Congradulations! &lt;br /&gt;
But wait… this transformation is not intuitive at all. You have implemented a natueal counter as a list of objects! 
Now you need to prove that your implementation is correct (i.e. behaves the same as the specifications given to you).
&lt;br /&gt; How are you going to proceed?&lt;/p&gt;

</description>
        <pubDate>Tue, 12 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://yourdomain.com/2016/04/12/CounterImpDef.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2016/04/12/CounterImpDef.html</guid>
        
        
      </item>
    
  </channel>
</rss>
