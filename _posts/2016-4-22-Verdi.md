---
layout: post
comments: true
title: Verdi, A Framework for Impementing and Formally Verifying Distributed Systems 
---
Assume you want to design a distributed system and you are told that you sould not be woried about the underlying network, since it is reliable. Every message is delivered exactly once and there is no site failure. You design and implement your system easily. You define nodes, states they preserve and also messages with appropriate handlers. Assume your system is a central counter that could be inceremented by clients. Obviously, possible messages from clients are `inc()` and `query()`. The server also can respond with `counter:n` where n is a natural number. <br>
Now you are asked for the specification of your system with a proof of correctness.
You define the following predicate for the traces of messages and prove that all possible traces in your system satisfy it:
<p> 
&#934;(&#964;) :=   &#964; =  &#964;<sub>1</sub>  ++   <x,counter:n> ++ &#964;<sub>2</sub> ++ <y,counter:n+1> ++  &#964;<sub>3</sub>     &#x2192; &exist;z, <z,inc()> =  &#964;<sub>2</sub> 
</p>
<p>So far everthing is working perfect, but after your system is actually implemented, they realize that the network has some bugs and drops messages, so the safety features of your system are violated. Now you are required to design another system and prove its correctness in this new environment. </p>
<p>Well, this is not a major problem for you, since there are already solutions for this problem in the community: simply add a sequence number to each message, and make sure that consecutive messages from each sender have consecutive numbers, otherwise ask the sender to send you the lost message. This just requires a simple wraper around your code that examines each message and compares its sequence number with the last message received from that sender, and takes proper actions. </p>
<p>However, you do not want to go over all steps again, specially proving the correctness of your system was by no mean trivial and it is now even harder.<br>That is where <a href="http://verdi.uwplse.org">Verdi</a> comes into play! If you had implemented and proved your system in Verdi, you could now simply pick another network semantics and rely on Verdi to generate a new code, new safety specifications and a new proof of correctness for the translated system. <p>  
<p> Verdi automatically, wraps your code with certain handlers to make it immune to different types of network faults and node crashes. It provides a spectrum of network semantics that you could chose from and returns translated system and proofs. you should only verify your application in an idealized fault model, and then apply a Verdi's Verified System Transformers to obtain an application that is <b>guaranteed</b> to have analogous properties in a more realistic environment.
